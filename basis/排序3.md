介绍一些线性排序的方法（时间复杂度为O(n)）：通排序、计数排序、基数排序。之所以做到线性的时间复杂度，主要原因是，这三个算法都是非基于比较的排序算法，不涉及元素之间的比较操作。

### 桶排序(Bucket Sort)

核心思想：就是将要排序的数据分到几个有序的桶里，每个桶里的数据在进行单独排序，最后把桶里的数据依次取出，组成的序列就是有序的。

实际上，桶排序对要排序的数据的要求是非常苛刻的。

1. 要排序的数据要很容易分成m个桶，并且，桶与桶之间要有天然的大小顺序。
2. 其次，数据要在各个桶之间分布是比较均匀的。极端情况，数据都被分在一个桶里面，那就退化成O(n log n)的时间复杂度了。


**桶排序比较适合用在外部排序中**。所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

比如10G的订单数据，我们希望按金额（假设金额都是正数）排序，但内存有限，就几百MB，这个时候可以先确定订单金额的最小最大值，用桶来进行存储，分成有序号的文件，订单金额不均匀分布，导致某个文件过大，我们可以再细分。单个桶可以用快排来进行排序。

### 计数排序(Counting Sort)

个人觉得：计数排序其实是桶排序的一种特殊情况。

核心思想：当要排序n个数据，所处的范围并不大的时候，比如最大值k，我们就可以把数据分为k个桶。没个桶内的数据的值都是相同的，省掉了桶内排序的时间。

比如高考有50万考生，分数最大900分，最低0分。数据的范围很小，可以分成901个桶，对应分数0到900分。只需要一次遍历每个桶。将桶内的数据考出就是有序的。因为只涉及到遍历，时间复杂度为O(n).


### 基数排序(Radix Sort)

基数排序对排序的数据是有要求的，需要分割出独立的**位**来比较，而且位之间有递进关系。如果a数据的高位比b数据大，那么低位就可以不用比较了。

比如10万个手机号码从小到大排序，先排序最后一位，在排序倒数第二位，以此类推，直到第一位。这里按照每一位来排序，必需要是稳定的排序算法，可以用桶排序或者计数排序来完成。


### 如何优化快速排序

Java 的  Collections.sort()采用的是堆排序实现，C语言使用快速排序实现排序函数。

快排在最坏的情况下时间复杂度为O(n^2)，这种情况的出现主要是因为分区点选择的不合理

理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。

1. 三数取中法：区间的首、中间、尾分别取出一个数，取中间大小的数。如果排序的数组比较大，可能要五数取中或十数取中了。
2. 随机法：从要排序的区间，随机选择一个元素作为分区点。不能保证每次随机的数都比较好，但也不怎么可能每次随机的数都很差。


C语言qsort()的实现：数据量小时(如1kb)，用了归并排序，数据量大时用的快速排序，区间的元素小于四个的时候，退化成插入排序。

快速排序要避免递归深度太深，qsort()是通过自己实现一个堆上的栈，手动模拟递归来解决的。
