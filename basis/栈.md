###  栈

栈：先进后出，后进先出，这是典型的“栈”结构。从操作特性来看，**栈是一种“操作受限”的线性表**，只允许在一端插入删除数据。

栈主要包含两个操作，入栈和出栈。

实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫做**顺序栈**，用链表实现的栈叫做**链式栈**。
	
    //基于数组实现的顺序栈
	public class ArrayStack {
	    private  String[] items;
	    private  int count;//栈中元素个数
	    private  int n; //栈的大小
	
	    /**
	     * 初始化数组，申请一个大小为n的数组空间
	     * @param n
	     */
	    public  ArrayStack(int n){
	        this.items = new String[n];
	        this.count = 0;
	        this.n = n;
	    }
	
	    /**
	     * 入栈操作
	     * @param item
	     * @return
	     */
	    public  boolean push(String item){
	        if(count == n){
	            return  false;
	        }
	        items[count] = item;
	        count++;
	        return  true;
	    }
	
	    /**
	     * 出栈操作
	     * @return
	     */
	    public String pop(){
	        if(count == 0){
	            return  null;
	        }
	        String tep = items[count - 1];
	        count--;
	        return  tep;
	    }
	
	}



不管是顺序栈还是链式栈，在入栈和出栈中，只需一两个临时变量存储空间，所以时间复杂度都为O(1);


### 支持动态扩容的顺序栈

上面那个例子基于数组实现的栈，是一个固定大小的栈。初始化时指定了栈的大小，栈满无法添加数据。链式栈尽管大小不受限制，但要存储next指针，消耗更多内存。所以基于数组实现一个可以动态扩容的栈。

其实这种支持动态扩容的栈并不常用，主要是复杂度分析。最好时间复杂度O(1),最坏时间复杂度O(n),最坏时间复杂度只有极个别出现，均摊时间复杂度的分析方法后，时间复杂度就是O(1).

### 栈的经典应用场景:函数调用栈

操作系统给每个线程分配了独立的内存空间，这种内存分配会组织成栈这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈。

### 栈在表达式中的应用

表达式：4+6*3-3,编译器是通过两个栈实现的，一个保存操作数的栈，一个保存运算符的栈。

从左向右遍历表达式，是数字直接入操作数栈，遇到运算符就与运算符的栈顶元素进行比较。运算符比站定元素的优先级高，就将当前运算符压入栈，如果运算符和栈顶元素的优先级一样或更低，取出运算符和两个操作数，进行计算，计算完的数压入栈，继续比较。

### 栈在括号匹配的应用

左括号入栈，右括号出栈匹配，完成后，栈应该为空，否则非法。


