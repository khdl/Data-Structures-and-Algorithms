### 链表


链表通过“指针“将一组零散的内存块串联起来使用，常见的链表有单链表
双向链表和循环链表。我们把内存块称为 “结点”

单链表：每个结点除了存储数据以外，还需要记录链上下个结点的地址，称为**后续指针 next**,单链表有两个结点是比较特殊的，是第一个和最后一个。我们称为头节点和尾结点。

头节点用来记录链表的基地址，有它就可遍历得到整条链表。尾结点的指针指向**空地址  NULL**，表示这是链表上的最后个结点。


数组插入、删除的时间复杂度为O(n)，而链表为O(1)。但是链表的随机访问就并不高效了，需要一个一个结点的依次比遍历。直到找到相应的结点，需要O(n)的时间复杂度。


循环链表：一种特殊的单链表。在于单链表的尾结点的指针指向的是头节点。循环链表的优点就是从链尾到链头比较方便。处理的数据具有环形结构时就适合才用，比如约瑟夫问题。

双向链表：双向链表需要额外的两个空间来存储后续结点和前驱结点的位置。虽然两个指针比较浪费空间，但是可以支持双向遍历。也是实际开发中最常用的链表。有些时候双向链表插入删除比单向链表高效（空间换时间）

数组的大小固定的，声明就要占用连续的内存空间。链表本身没有大小限制，天然的支持动态扩容。


### 如何基于链表实现 LRU 缓存淘汰算法

思路：维护一个有序的单向链表，越靠近尾部的数据是越早之前访问的。

当有一个数据被访问时，我们从链表头顺序遍历。

1. 数据如果已经存在，从原来位置删除，然后插入到链表头部。
 
2. 如果不存在。
 - 缓存没满，直接插入链表头。
 - 缓存已满，删除尾结点，新数据插入链表头。


这种不管链表满没满，都要遍历，时间复杂度 为O(n)，实际上可以优化，比如散列表。


###  如何正确的写出链表代码

