
### 链表


链表通过“指针“将一组零散的内存块串联起来使用，常见的链表有单链表
双向链表和循环链表。我们把内存块称为 “结点”

单链表：每个结点除了存储数据以外，还需要记录链上下个结点的地址，称为**后续指针 next**,单链表有两个结点是比较特殊的，是第一个和最后一个。我们称为头节点和尾结点。

头节点用来记录链表的基地址，有它就可遍历得到整条链表。尾结点的指针指向**空地址  NULL**，表示这是链表上的最后个结点。


数组插入、删除的时间复杂度为O(n)，而链表为O(1)。但是链表的随机访问就并不高效了，需要一个一个结点的依次比遍历。直到找到相应的结点，需要O(n)的时间复杂度。


循环链表：一种特殊的单链表。在于单链表的尾结点的指针指向的是头节点。循环链表的优点就是从链尾到链头比较方便。处理的数据具有环形结构时就适合才用，比如约瑟夫问题。

双向链表：双向链表需要额外的两个空间来存储后续结点和前驱结点的位置。虽然两个指针比较浪费空间，但是可以支持双向遍历。也是实际开发中最常用的链表。有些时候双向链表插入删除比单向链表高效（空间换时间）

数组的大小固定的，声明就要占用连续的内存空间。链表本身没有大小限制，天然的支持动态扩容。


### 如何基于链表实现 LRU 缓存淘汰算法

思路：维护一个有序的单向链表，越靠近尾部的数据是越早之前访问的。

当有一个数据被访问时，我们从链表头顺序遍历。

1. 数据如果已经存在，从原来位置删除，然后插入到链表头部。
 
2. 如果不存在。
 - 缓存没满，直接插入链表头。
 - 缓存已满，删除尾结点，新数据插入链表头。


这种不管链表满没满，都要遍历，时间复杂度 为O(n)，实际上可以优化，比如散列表。


###  如何正确的写出链表代码

- 理解指针或引用的含义（存储所指对象的内存地址）

 - 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。通过指针就能找到这个变量。</br>
  在编写链表代码的时候，会遇到代码： p->next=q 这行代码是说p结点的next指针存储了q结点的内存地址。</br>更复杂一点的： p->next=p->next->next表示p结点的next指针存储了p结点的下下结点的内存地址。

- 警惕指针丢失或内存泄漏
 
  - 写链表代码的时候，指针指来指去，一会就不知道指到哪了，写的时候不要弄丢了指针。
  
- 利用哨兵简化实现难度
  
 - 回顾单链表的插入删除，如果在结点p后插入一个新结点，只需两行代码：
 
		 
			new_node->next=p->next;
			p->next = new_node;

  - 但是，向一个空链表中插入第一个结点，需要进行特殊处理，其中head表示链表的头结点指针。
  
			  if(head  == null){
			     head = new_node;
			  }


 - 单链表的删除操作，只需一行代码

			p->next=p->next->next；
			//如果是最后一个结点
			if(head->next == null){
			   head = null;
			}


 - 从前面的分析，我们需要针对链表插入第一个结点和删除最后一个结点进行特殊处理。这样很繁琐，如何解决？</br>
  哨兵解决的是边界问题，不直接参与业务逻辑。引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。有哨兵结点的链表叫带头链表，相反叫不带头链表。</br>
  哨兵结点是不存储数据的，插入第一个和其他，删除最后一个和其他都可以统一的代码实现逻辑。

- 重点留意边界处理条件

  - 如链表为空？只包含一个结点？只包含两个结点？处理头节点或尾结点？这些能不能正常工作？

- 举例画图，辅助思考


