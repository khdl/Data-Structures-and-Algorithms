#  分析统计算法的执行效率和资源消耗

### 为什么要复杂度分析（时间、空间）

事后统计法：把代码跑一遍，通过统计监控得到算法的执行时间和占用内存大小.

这种方法的局限性：

 - 测试结果非常依赖测试环境
 - 测试结果受数据规模的影响很大

所以需要一个不用具体的测试数据来测试，就可以粗略估计算法的执行效率，这就是时间、空间复杂度分析方法


### 大 O 复杂度表示法

算法的执行效率（简单说就是算法的执行时间）

求 1,2,3...n 的累加和

	  int  calculate(int n) {
        int sum =0;
        int i=1;
        for (; i < n; i++) {
            sum = sum +i;
        }
        return  sum;
    }


假设每行代码执行时间是一样的，为1，这段代码需要2n+2的时间。

总结 代码的执行时间与每行代码的执行次数成正比

	
	 int  calculate(int n) {
	        int sum =0;
	        int i=1;
	        int j=1;
	        for (; i < n; ++j) {
	            j=1;
	            for (; j < n; ++j) {
	                sum = sum +i*j;
	            }
	
	        }
	        return  sum;
	    }

假设每行代码执行时间是一样的，为1，这段代码需要2n^2+2n+3的时间。

可以推断代码的执行时间T(n)与每行代码的执行次数成正比

T(n) =O (f(n))

所以时间复杂度第一个例子T(n) = O(2n+2) ,第二个例子 T(n) = O(2n^2+2n+3)  ，这就是大O 复杂度表示法。

大O 复杂度不具体表示代码的真正执行时间，而是表示代码的执行时间随数据规模增长的变化趋势，简称时间复杂度

当n 非常大的时候吗，公式的低阶、系数、常量 并不左右增长，可以记为 T(n) =O(n),T(n)=O(n^2)


### 如何分析一段代码的时间复杂度

1. 只关注循环执行次数最多的一段代码
   
  - 因为公式的低阶、系数、常量可以忽略，所以关注循环执行次数最多的那一段
 
  
2. 总复杂度等于量级最大的那段代码的复杂度


3. 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


### 常见的时间复杂度量级

常量阶：O(1)   &nbsp;  &nbsp;  指数阶：O(2^N)    &nbsp; &nbsp;对数阶：O(log n)

阶乘阶： O(n!) &nbsp; &nbsp;   线性阶：  O(n)   &nbsp; &nbsp;   线性对数阶： O(n log n)

平方阶：O(n^2)  &nbsp; &nbsp;   立方阶： O(n^3) &nbsp; &nbsp;   k次方阶：O(n^k)

非多项式量级：O(2^n)和O(n!),NP问题(非确定多项式问题)，n 越来越大，时间会急剧增加
这种复杂度算法非常低效。

其余是多项式量级的（以上罗列粗略分法）



### O(1)
  

执行时间不随n的增长而增大

只要算法中不存在循环语句、递归语句，即使代码行成千上万，时间复杂度也是O(1)


### O(log n)、O(n log n)
 

对数阶时间复杂度非常常见，但比较难分析

          i= 1;
          while (i <= n){
              i= i * 2;
          }


时间复杂度为O(log2 n)

由于对数可以相互转换，公式的系数可以忽略，我们把所有对数阶的时间复杂度都表示为O(log n),忽略对数的底数

O(n log n)  表示循环执行了 n 遍 时间复杂度为O(log n)的代码。这个也很常见，归并排序、快速排序的时间复杂度就是这个


### O(m+n)、O(m*n)

代码复杂度由两个数据规模来决定，并且无法评估m和n的大小




### 空间复杂度

渐进空间复杂度，表示算法的存储空间与数据规模的增长关系

常见的空间复杂度：O(1),o(n),O(n^2),像O(log n),O(n log n)这样的复杂度平时都用不到



### 总结

越高阶的复杂度算法，执行效率就越低，从低到高是：O(1),O(log n),O(n),O(n log n),O(n^2)

