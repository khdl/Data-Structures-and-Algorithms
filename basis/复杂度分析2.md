### 最好、最坏情况时间复杂度

	//n为数组长度
	 int  find(int[] array,int n,int x) {
	       int i = 0;
	       int pos = -1;
	        for (; i < n; i++) {
	            if(array[i] == x){
	                pos = i;
	            }
	        }
	        return  pos;
	    }


这段代码就是找出 x 在array 数组的位置，没有返回 -1；时间复杂度就为O(n),但查找一个数据不需要把数组都遍历一遍。

	int  find(int[] array,int n,int x) {
	       int i = 0;
	       int pos = -1;
	        for (; i < n; i++) {
	            if(array[i] == x){
	                pos = i;
	                break;
	            }
	        }
	        return  pos;
	    }

上面代码x在第一个元素，那么时间复杂度就为O(1)，如果x不存在，那么时间复杂度就为O(n)


最好情况时间复杂度：在最理想的情况下执行这段代码的时间复杂度

最坏情况时间复杂度：在最糟糕的情况下执行这段代码的时间复杂度

### 平均情况时间复杂度

x出现在数组中有n+1中情况，在数组的0到n-1位置和不在数组中，把每种元素出现的情况累加起来，除以n+1，得到平均时间复杂度。省略低阶、系数、常量后为O(n)

但每个位置x出现的概率可能不一样，这时候就要算加权平均值，也叫期望值。所以平均时间复杂度也加加权平均时间复杂度或期望时间复杂度。


### 均摊时间复杂度

这种时间复杂度分析很少用到，用摊还分析法分析


对一个数据结构进行一组连续操作中，大部门情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候可以把一组操作放在一起分析。一般均摊时间复杂度等于最好情况时间复杂度。

个人觉得均摊时间复杂度是一种特殊的平均时间复杂度。

### 小结

之所以映引入这好几个概念，是因为同段代码，在不同输入的情况下，复杂度量级可能是不一样的。



