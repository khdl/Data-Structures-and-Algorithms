### 散列表(Hash Table)

散列表我们平时也叫哈希表、Hash表。</br>
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展。

把键转换为数组下标的映射方法就叫做散列函数(Hash函数、哈希函数)，散列函数计算得到的值叫做散列值(Hash值、哈希值)

### 哈希函数

哈希函数：可以把它定义为hash(key)，其中key表示元素的键值。

哈希函数的基本要求：

1. 哈希函数计算得到的值是一个非负整数；
2. 如果key1 = key2，那hash(key1) = hash(key2);
3. 如果key1 != key2，那hash(key1) != hash(key2).

第3点可能会有点问题，真实情况下，要找到一个不同的key对应的哈希值都不一样的散列函数几乎是不可能的，即便MD5、SHA、CRC算法，也无法完全避免这种散列冲突。

### 散列冲突

常用的解决散列冲突的方法：开放寻址法和链表法

1. 开放寻址法：如果出现了散列冲突，就重新探测一个空闲位置，将其插入。如何探测新的位置？
 
  - 线性探测：经过散列函数后，存储位置已经被占用了，从当前位置开始。依次往后查找，看是否有空闲位置，直到找到为止。
  - 二次探测：跟线性探测很像，线性探测每次探测的步长为1，二次探测的步长就变成了原来的二次方。
  - 双重散列：意思是说用不止一个散列函数，当第一个散列函数计算的存储位置已经被占用后，再用第二个散列函数，依次类推，知道找到空闲位置的值为止。

    不管哪种散列方法，散列表的空闲位置不多的时候，散列冲突的概率就会大大提升。为了保证散列表的操作效率，一般情况，我们会尽可能保证散列表中有一定比例的空闲槽位。用**装载因子**来表示空位的多少。

	     装载因子 = 填入表的元素个数/散列表的长度

2. 链表法
  
  链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它简单很多。在散列表中，每个桶或槽会对应一条链表，所有散列值相同的元素都会放到同槽位对应的链表中。

word里面的单词拼写检查，可以用散列表来实现。



