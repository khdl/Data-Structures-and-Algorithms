### 散列表(Hash Table)

散列表我们平时也叫哈希表、Hash表。</br>
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展。

把键转换为数组下标的映射方法就叫做散列函数(Hash函数、哈希函数)，散列函数计算得到的值叫做散列值(Hash值、哈希值)

### 哈希函数

哈希函数：可以把它定义为hash(key)，其中key表示元素的键值。

哈希函数的基本要求：

1. 哈希函数计算得到的值是一个非负整数；
2. 如果key1 = key2，那hash(key1) = hash(key2);
3. 如果key1 != key2，那hash(key1) != hash(key2).

第3点可能会有点问题，真实情况下，要找到一个不同的key对应的哈希值都不一样的散列函数几乎是不可能的，即便MD5、SHA、CRC算法，也无法完全避免这种散列冲突。

散列函数不能设计的太复杂，否则计算会消耗很多时间，间接影响散列表的性能。</br>
散列函数生成的值要尽可能随机并且均匀分布。

散列函数的设计方法有很多，比如直接寻址法、平方取中法、折叠法、随机数法等。

### 散列冲突

常用的解决散列冲突的方法：开放寻址法和链表法

1. 开放寻址法：如果出现了散列冲突，就重新探测一个空闲位置，将其插入。如何探测新的位置？
 
  - 线性探测：经过散列函数后，存储位置已经被占用了，从当前位置开始。依次往后查找，看是否有空闲位置，直到找到为止。
  - 二次探测：跟线性探测很像，线性探测每次探测的步长为1，二次探测的步长就变成了原来的二次方。
  - 双重散列：意思是说用不止一个散列函数，当第一个散列函数计算的存储位置已经被占用后，再用第二个散列函数，依次类推，知道找到空闲位置的值为止。

    不管哪种散列方法，散列表的空闲位置不多的时候，散列冲突的概率就会大大提升。为了保证散列表的操作效率，一般情况，我们会尽可能保证散列表中有一定比例的空闲槽位。用**装载因子**来表示空位的多少。

	     装载因子 = 填入表的元素个数/散列表的长度

2. 链表法
  
  链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它简单很多。在散列表中，每个桶或槽会对应一条链表，所有散列值相同的元素都会放到同槽位对应的链表中。


数据量、装载因子比较小的时候，适合用开放寻址法。Java中的ThreadLocalMap就是用的开放寻址法。</br>
链表法更加普遍，比较适合存储大对象、大数据的散列表，比起开发寻址法，它更加灵活，比如用红黑树代替链表。

word里面的单词拼写检查，可以用散列表来实现。

### 装载因子

散列表的装载因子超过某个阈值时，就要进行动态扩容。这个阈值要选择得当。太大会导致冲突过多，太小会导致内存浪费。

低效扩容：某次操作导致散列表扩容，如果散列表数据大，那么这次操作很耗时。</br>
如何避免：可以将扩容操作穿插在插入操作中，分批完成。

### LinkedHashMap 

LinkedHashMap保证了元素加入散列表的顺序，每次添加元素的时候都是加入双向链表的尾部。其中的linked是指双向链表，并非指用链表法解决散列冲突

