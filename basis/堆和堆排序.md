# 堆和堆排序

### 堆

堆是一种特殊的树，满足下面两点的树就是堆：

1. 堆是一个完全二叉树
2. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值

对于每个节点的值都大于等于子树中每个节点的值的堆叫**大顶堆**，对于每个节点的值都小于等于子树中每个节点的值的堆叫**小顶堆**。

如何实现一个堆？
要实现一个堆，要先知道，堆都支持哪些操作以及如何存储一个堆。

完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。数组中小标为i的节点的左节点就是下标为i * 2的节点，右节点就是下标为 i * 2 + 1的节点。

往堆中插入一个元素，把元素放到堆的最后，就不符合堆的特性了。所以需要对其进行调整，让其重新满足堆的特性，这个过程叫做**堆化**。堆化实现上有两种，从下往上和从上往下。就是向下和向上顺着节点的路径，对比，然后交换。

堆顶元素存储的就是堆中数据的最大值或最小值。

一个包含n个节点的完全二叉树，树的高度不会超过log n，堆化的过程就是顺着节点的路径比较交换，堆化的时间复杂度跟树的高度成正比。插入数据和删除堆顶元素的主要逻辑就是堆化，所以插入数据和删除堆顶元素的时间复杂度就是O(log n)。

### 如何基于堆实现排序

借助于堆这种数据结构实现的排序算法，就叫做**堆排序**。这中排序算法的时间复杂度为O(n log n),并且还是原地排序算法，但不是稳定的。

堆排序的大致过程分为两个大的步骤：

1. 建堆：首先将数组原地建成一个堆。原地就是说不借助另一个数组，就只在原数组上操作。建堆的时间复杂度是O(n)。
2. 排序： 用数组第一个元素放到最后，堆化后第一个元素 在放到n - 1的位置，直到堆中的元素还剩一个。时间复杂度为O(n log n)。

堆排序整体的时间复杂度为O(n log n)。

实际开发中，为什么快速排序要比堆排序的性能好?

1. 堆排序的数据仿问的方式没有 快速排序友好。快排数据是顺序访问的，堆排序中数据是跳着访问的。
2. 对于同样的数据,排序过程中，堆排序的数据交换次数要多于快速排序。

### 堆的应用

非常重要的几个应用：优先级队列、求 TOP K和求中位数

优先级队列：数据的出队顺序不是先进先出，而是按照优先级来的。优先级最高的，最先出队。实现优先级队列的方法有很多，堆是最直接、高效的。取出优先级最高的元素就相当于取出堆顶的元素。许多 算法依赖它，比如赫夫曼编码、图的最短路劲、最小生成树算法等。Java的PriorityQueue就是优先级队列。

- 合并有序的小文件：比如100个100M的文件合并成一个大文件(每个文件存储有序的字符串)，维护一个100数据的小顶堆。循环取数据、插入数据，直到各个文件没有数据。
- 高性能的定时器:把定时任务的执行时间维护成一个堆

TOP K：就是维护一个小顶堆，分为静态数据集合，和动态数据集合。动态数据集合在数据插入的时候，把数据用来和小顶堆堆顶元素数据对比。

求中位数(变形：不一定是中位数,可能是某个比例)：就是维护一个大顶堆和一个小顶堆，大顶堆存前面的数据，小顶堆存后面的数据。大顶堆堆顶元素就是中位数。如果数据在变动，不满足存储数据的比例，就将一个堆中的数据移动到另一个堆，直到满足比例。