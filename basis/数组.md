# 数组

### 如何实现随机访问

数组：数组（array）是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**，

理解其中的关键词：

  - 线性表：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，队列、链表、栈也是线性表结构。对立的是非线性表结构，比如二叉树、堆、图等，数据之间并不是简单的前后关系。
  - 连续的内存空间和相同的数据类型：正是因为这两个限制，数组才了特性**随机访问**，但弊端是让数组的插入和删除操作变得非常低效，因为为了保证连续性，需要做大量的数据搬移工作。

### 数组如何实现随机访问的

数组存在一个首地址，用首地址+（i+数组元素大小），找到元素存储地址。

数组和链表的区别：链表适合插入、删除，时间复杂度为O(1),数组适合查找，查找时间复杂度为O(1).其实这种说法不准确，数组查找的时间复杂度并不是O(1),即便排序号的数组，用二分查找，时间复杂度也为O(log n)。应该说数组支持随机访问。


### 低效的插入和删除

为了保证内存数据的连续性，导致插入和删除操作比较低效。

分析插入的时间复杂度：最好时间复杂度O(1),最坏时间复杂度O(n),因为在每个位置插入的元素的概率是一样的，所以平均时间复杂度为(1+2+...n)/n = O(n).

有什么改进呢？如果在k位置插入一个元素，那么k之后的数据都要搬移。特定场景下，如果数组只被当成一个存储数据的集合，那么我们可以直接把k位置的数据搬移到数组的最后，然后k位放新元素。这样把数组的插入时间复杂度降为O(n),这个思想在快排中用到。

删除的时间复杂度和插入类似为O(n),在某些特定的场景下，我们可以把多次删除操作集中在一起执行，删除的效率会提高。比如数组8个元素，删除前3个，为了避免后5个元素搬移3次，我们先记录下删除的数据，并不真正的搬移数据，当数组没有更多的存储空间时，我们再触发一次真正的删除。这样就减少了数据的搬移工作。其实这就是JVM标记清除 垃圾回收算法的核心思想。

### 警惕数组的访问越界

Java 本身会带越界检查。但是C语言没有，很多病毒也是利用到了代码中数组越界可以访问非法地址的漏洞，来攻击系统。

### 容器能否完全替代数组

比如Java 的ArrayList ，与数组相比，有哪些优势？

个人觉得，ArrayList最大的优势就是**可以将很多数组操作细节封装起来**。比如数组插入、删除需要搬移其他数据等。另外一个优势是**支持动态扩容**，如果使用ArrayL数据存储空间不够的时候，都会自动将空间扩容为原来的1.5倍大小。

不过扩容是比较耗时的，最好在创建ArrayList的时候就指定数据的大小。

有些时候，用数组更合适：

- Java ArrayList无法存储基本数据类型，需要封装。但自动装箱和拆箱有一定的性能消耗。或者希望使用基本类型，可以用数组。

- 如果数据大小已知，并对数据的操作非常简单，用不到ArrayList 提供的大部分方法，也可以直接使用数组。

总结下，对于业务开发，直接使用容器就好了，省时省力。




