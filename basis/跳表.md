### 跳表

跳表：**链表加多级索引的结构**

如果每两个结点抽取一个结点作为上一级索引的结点，第一级索引的个数大约为n/2，第二级索引的个数大约为n/4，第三级索引的个数大约为n/8，以此类推，第k级的索引的个数大约为n/（2^k）。</br>
如果每一级都要遍历m个结点，那在跳表中查询一个数据的时间复杂度为O（m*log n）。</br>
所以在跳表中查询任意数据的时间复杂度就是O(log n)。

### 跳表是不是很浪费内存

比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。

假如原始链表大小为n，第一级索引大约有n/2个结点，第二级索引大约有n/4个结点，第三级索引大约有n/8个结点，以此类推，跳表的空间复杂度是O(n)

可以 每三个结点(或者数量跟多)抽取一个结点作为上一级索引的结点，来减少索引创建的空间

在实际使用中，有时可以不必太在意索引占用的额外空间。因为原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，不需要存储对象，所以对象比索引结点大很多的时候，那索引占用的额外空间就可以忽略不记了。

### 高效的动态插入和删除

跳表这个动态数据结构，不仅支持查找操作，也支持动态的插入、删除操作。插入、删除的时间 复杂度为O(log n)

插入：先找到插入的位置，这个操作比较耗时。
删除：删除操作的时候，一定要获得其前驱结点，因为删除通过指针来完成操作的。

### 跳表索引动态更新

不停的向跳表中插入数据的时候，，如果不更新索引，会可能出现两个索引结点之间数据非常多的情况。极端情况下，跳表退化成单链表。

需要某种手段来维护索引与原始链表大小之间的平衡。跳表是通过随机函数来维护这种平衡关系。

当我们向跳表中擦插入数据的时候，可以选择同时将这个数据插入到部分索引层中。通过一个函数，来决定将这个结点插入到几级索引中。比如随机函数生成了一个k，那么将这个结点添加到第一级到第k级的索引中。

### 为什么Redis要用跳表来实现有序集合，而不是红黑树

Redis 中的有序集合是用跳表来实现的，严格来说还用到了散列表。

按照区间来查找数据，红黑树的效率没有跳表高。

比起红黑树来，跳表代码更容易实现。

跳表更加灵活，可以通过改变索引的构建策略，有效的平衡执行效率和和内存消耗。

跳表也不能完全替代红黑树。



