### 排序

排序算法太多了，有些可能连名字都没听过。就下来总结一些常用的排序算法。


	排序算法            时间复杂度        是否基于比较
	冒泡、插入、选择      O(n^2)            是
	快排、归并           O(n log n)        是
	桶、计数、基数        O(n)              否


### 如何分析一个排序算法

1. 排序算法的执行效率
2. 排序算法的内存消耗
 - 原地排序算法：特指空间复杂度为O(1)的算法（冒泡、插入、选择都是原地排序算法）
3. 排序算法的稳定性
 - 稳定的排序算法：相同的元素排序后，前后顺序没有改变
 - 不稳定的排序算法：相同的元素排序后，前后顺序发生改变。

### 冒泡排序(Bubble Sort)

冒泡排序只会操作相邻两个数据，每次比较相邻的两个元素，不满足大小要求使它们进行互换。一次冒泡至少会让一个元素移动到它应该在的位置。重复n次，就完成了n个数据的排序工作。

冒泡的优化：某次冒泡没有数据交换了，说明已经达到了完全有序，不需要进行后面的冒泡操作了。

    //a是数组，n为数组长度
	public void bubbleSort(int[] a,int n){
		if(n <= 1){
			return;
		}
		for(int i=0;i < n;i++){
			boolean flag = false;
			for(int j = 0;j <n -i-1;j++){
				if(a[j] > a[j+1]){
					int tmp =a[j];
					a[j] = a[j+1];
					a[j+1] = tmp;
					flag =  true;
				}
			}
			if(!flag){
				break;
			}
		}
	}


冒泡排序是原地排序算法：只涉及相邻数据操作，空间复杂度为(1)。

冒泡排序是稳定排序算法：只有交互才该变两个元素的顺序，当有相邻的两个元素大小相等时，不做交换所以大小相等的数据前后顺序没有改变。

最好时间复杂度(完全有序):O(n)</br>
最坏时间复杂度(完全逆序):O(n^2)</br>
平均时间复杂度:O(n^2)

### 插入排序(Insertion Sort)

插入排序：分为已排序区间和未排序区间。初始已排序区间就只有一个元素，核心思想就是取未排序区间的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间一直有序，知道未排序区间的元素个数为空。

包含两种操作：元素的比较和元素的搬移。移动操作的次数总是固定的，就等于逆序度。

	public static  void  insertionSort(int[] a,int n){
			if(n <= 1){
				return;
			}
			
			for(int i=1;i <= n;i++){
				int value = a[i];
				int j = i-1;
				for(;j >= 0;j--){
					if(a[j] > value){
						a[j+1] = a[j];//数据移动
					}else{
						break;
					}
				}
				a[j+1] = value;//插入数据
			}
		}



插入排序是原地排序算法：不需要额外的存储空间，空间复杂度为O(1)

插入排序是稳定的排序算法：对于值相同的元素，我们可以选择将后面出现的元素插入到前面出现元素的后面。

最好时间复杂度(完全有序):O(n)</br>
最坏时间复杂度(完全逆序):O(n^2)</br>
平均时间复杂度:O(n^2)