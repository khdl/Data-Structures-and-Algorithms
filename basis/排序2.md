### 归并排序(Merge Sort)

核心思想：将一个数组从中间分为两部分，然后对前后两部分分别进行排序，再将排好序的两部门合并在一起。这样整个数组就有序了。

归并排序使用的分治思想。

分治：将一个大问题分解成小的问题来解决。

分治是一种解决问题的处理思想，递归是一种编程技巧。

	递推公式：
	merge_sort(p...r)=merge_sort(p...q)+merge_sort(q+1...r);
	终止条件：p>=r 不能继续分解


merge_sort(p...r) 给下标从p到r之间的数组进行排序。分为两部分进行排序，排序好后进行合并成一个有序的数组。
	
	//伪代码
	//归并排序算法，A为数组，n为数组大小
	merge_sort(A,n){
	   merge_sort_c(A,o,n-1);
	}
	
	//递归调用函数
	 merge_sort_c(A,p,r){
	     if p>=r then return
		//从p到r取中间条件
		q = (p + r)/2
		//分治递归
		merge_sort(A,p,q)
		merge_sort(A,q+1,r)
		//合并两个数组
		merge(A[p...r],A[p...q],A[q+1...r])
	}

merge 函数的作用将已经有序的两个数组进行合并成一个有序的数组，实现：申请一个A[p...r]大小的数组，比较两个数组中元素的大小，依次放入数组知道其中一个数组没有数据，再将另一个数组中的元素依次加入末尾。


归并排序是稳定的排序算法，在合并的过程中先放A[p...q]的元素，达到稳定排序的目的。

归并排序的时间复杂度很稳定,最好、最坏、平均时间复杂度都为O(n log n).

归并排序的空间复杂度为O(n),在合并数据的时候会借助临时的内存空间，不是原地排序算法(没有快排应用广泛的缺点)

### 快速排序(Quick Sort)

核心思想：排序数组p到r之间的一组数据，选择其中任意一个数据作为分区点(pivot,一般选取最后一个)，小于pivot放在左边，大于的放在右边。分治、递归处理思想，直道区间缩小为1，说明数组有序了。


	递推公式：
	quick_sort(p...r) = quick_sort(p...q-1)+quick_sort(q+1,r)
	终止条件：p>=r 不能继续分解

</br>

	//伪代码
	//快速排序，A是数组，n是数组大小
	quick_sort(A,n){
	     quick_sort_c(A,o,n-1);
	}
	//快速排序递归函数，p，r为下标
	 quick_sort_c(A,p,r){
	    if p>=r then return
	   
	    q = partition(A,p,r)//获取分区点
	    quick_sort(A,p,q-1)
	    quick_sort(A,q+1,r)
	}


其中有个partition()分区函数：随机选择一个元素作为pivot，不考虑空间复杂度，这个函数可以写的很简单，申请两个临时数组进行数据存放。但是这样就不是原地排序算法了。</br>
有个巧妙的实现方式:数组分为已处理空间(初始为0)和未处理空间。每次从未处理空间取出一个元素与pivot比较。小于则加入已处理空间尾部。这里处理插入数据是采用数据交换的思想。因为有数据交换，不能保证元素的前后顺序，所以快排并不是一个稳定的排序的算法。


###  快排和归并的区别

归并的排序是 **由下到上** 的，先处理子问题再合并，快排的排序是 **由上到下** 的，先分区再处理子问题。**归并并不是原地排序算法**。

快排的时间复杂度大部分都是O(n log n),极端情况下是O(n^2)。而且有很多种方法将这种极端情况降的很低。

### 时间复杂度O(n)内查找数组地第k大的元素

思路：就是快排的思路，分区，如果p+1=k，那么A[k]就是要求解的元素。