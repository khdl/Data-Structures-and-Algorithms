### 二叉树

树，父节点，子节点，兄弟节点，根节点，叶子节点(叶节点)

节点的高度：节点到叶节点的最长路径</br>
节点的深度：根节点到这个节点所经历的边的个数</br>
节点的层数：节点的深度 + 1</br>
树的高度：根节点的高度</br>

二叉树：每个节点最多有两个节点，分别为左子节点和右子节点</br>
完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，除了最后一层，其它层的节点数都要达到最大。</br>
满二叉树：叶子节点都在最后一层，除了最后一层每个节点都有左右两个子节点。


### 二叉树的存储

有两种方法：</br>
1.  基于引用的二叉树链式存储法。</br>
2.  基于数组的顺序存储法。

链式存储法：比较简单、直观，每个节点有三个字段，一个存储数据，另外两个是指向左右子节点的引用。大部分二叉树都是通过这种方式来实现的。

顺序存储法：把根节点存储在i为1的位置，下标为2*i的位置存储的就是左节点，下标为2*i+1存储的就是右节点。二叉树如果不是完全二叉树，用这种方式就会浪费很多内存存储空间。

### 二叉树的遍历

前序遍历：本身、左节点、右节点</br>
中序遍历：左节点、本身、右节点</br>
后序遍历：左节点、右节点、本身


遍历的过程就是一个递归的过程
	
	//前序遍历
	void preOrder(Node node){
	if(node == null) return;
	print node;
	preOrder(root->left);
	preOrder(root->right);
	}
	
	//中序遍历
	void inOrder(Node node){
	if(node == null) return;
	inOrder(root->left);
	print node;
	inOrder(root->right);
	}
	
	后序遍历
	void postOrder(Node node){
	if(node == null) return;
	postOrder(root->left);
	postOrder(root->right);
	print node;
	}


### 二叉查找树

定义：二叉查找树中，在树中的任意一个节点，左子树的值都要小于这个值，右节点的值都要大于这个值。

重要特性：中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度为O(n)，非常高效，所以也叫二叉排序树。

实际开发中。二叉查找树中存的是包含多个字段的对象，利用对象的某个键值来构建二叉查找树。

如果二叉查找树中的值有重复的值，处理方法：

- 把相同的值存在同一个节点上
- 每个节点只存一个值，相同的值存在右边。查找的时候遇到相同的值不停止查找，而是继续在右子树查找，直到遇到叶子节点。

二叉查找树的插入、删除、查找的时间复杂度与树的高度成正比。极端情况下退化成链表。

